
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Wed Feb 03 03:24:31 CET 2021
//----------------------------------------------------

package compiler.syntax;

import java_cup.runtime.Symbol;
import java.util.*;
import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;
import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Wed Feb 03 03:24:31 CET 2021
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\214\000\002\002\004\000\002\042\002\000\002\002" +
    "\004\000\002\003\006\000\002\004\004\000\002\004\002" +
    "\000\002\005\006\000\002\005\006\000\002\006\004\000" +
    "\002\006\004\000\002\006\004\000\002\006\002\000\002" +
    "\007\004\000\002\007\004\000\002\007\002\000\002\010" +
    "\011\000\002\010\011\000\002\011\005\000\002\011\005" +
    "\000\002\011\005\000\002\011\005\000\002\012\005\000" +
    "\002\012\005\000\002\012\003\000\002\013\005\000\002" +
    "\013\005\000\002\013\003\000\002\015\003\000\002\015" +
    "\003\000\002\016\010\000\002\016\010\000\002\016\010" +
    "\000\002\017\010\000\002\017\010\000\002\017\010\000" +
    "\002\020\007\000\002\020\010\000\002\020\010\000\002" +
    "\022\004\000\002\022\004\000\002\022\002\000\002\023" +
    "\003\000\002\023\003\000\002\023\003\000\002\023\004" +
    "\000\002\041\004\000\002\041\004\000\002\041\004\000" +
    "\002\041\005\000\002\041\004\000\002\041\004\000\002" +
    "\041\004\000\002\041\004\000\002\041\005\000\002\041" +
    "\004\000\002\041\004\000\002\024\003\000\002\024\003" +
    "\000\002\024\005\000\002\024\005\000\002\024\005\000" +
    "\002\024\005\000\002\024\005\000\002\024\004\000\002" +
    "\024\003\000\002\024\003\000\002\024\005\000\002\024" +
    "\005\000\002\024\005\000\002\024\004\000\002\024\004" +
    "\000\002\025\005\000\002\025\005\000\002\025\004\000" +
    "\002\025\005\000\002\025\005\000\002\025\004\000\002" +
    "\025\005\000\002\025\005\000\002\025\005\000\002\025" +
    "\005\000\002\026\007\000\002\026\011\000\002\026\011" +
    "\000\002\026\007\000\002\026\011\000\002\026\011\000" +
    "\002\026\007\000\002\026\011\000\002\026\011\000\002" +
    "\026\007\000\002\026\011\000\002\026\011\000\002\030" +
    "\011\000\002\036\011\000\002\036\007\000\002\036\006" +
    "\000\002\036\007\000\002\036\011\000\002\036\007\000" +
    "\002\036\006\000\002\036\007\000\002\036\002\000\002" +
    "\031\007\000\002\031\007\000\002\031\007\000\002\031" +
    "\007\000\002\035\006\000\002\035\006\000\002\035\006" +
    "\000\002\034\005\000\002\034\005\000\002\034\005\000" +
    "\002\033\006\000\002\033\006\000\002\033\006\000\002" +
    "\033\006\000\002\033\006\000\002\033\006\000\002\033" +
    "\006\000\002\033\006\000\002\032\006\000\002\032\006" +
    "\000\002\032\006\000\002\032\006\000\002\014\006\000" +
    "\002\014\006\000\002\014\006\000\002\014\006\000\002" +
    "\037\005\000\002\037\003\000\002\037\005\000\002\037" +
    "\002\000\002\021\006\000\002\021\006\000\002\021\004" +
    "\000\002\021\002\000\002\040\006\000\002\040\006\000" +
    "\002\040\006" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\u0117\000\014\016\000\020\000\032\000\033\000\046" +
    "\000\001\002\000\004\002\u0119\001\002\000\014\016\ufffc" +
    "\020\ufffc\032\ufffc\033\ufffc\046\ufffc\001\002\000\004\002" +
    "\uffff\001\002\000\014\016\010\020\ufff6\032\ufff6\033\ufff6" +
    "\046\ufff6\001\002\000\004\046\u0115\001\002\000\012\020" +
    "\013\032\020\033\017\046\021\001\002\000\014\016\ufffd" +
    "\020\ufffd\032\ufffd\033\ufffd\046\ufffd\001\002\000\004\046" +
    "\u0107\001\002\000\036\002\ufff7\003\ufff7\020\ufff7\021\ufff7" +
    "\022\ufff7\023\ufff7\024\ufff7\027\ufff7\030\ufff7\032\ufff7\033" +
    "\ufff7\043\ufff7\044\ufff7\046\ufff7\001\002\000\036\002\uffe6" +
    "\003\uffe6\020\uffe6\021\uffe6\022\uffe6\023\uffe6\024\uffe6\027" +
    "\uffe6\030\uffe6\032\uffe6\033\uffe6\043\uffe6\044\uffe6\046\uffe6" +
    "\001\002\000\036\002\ufff9\003\ufff9\020\ufff9\021\ufff9\022" +
    "\ufff9\023\ufff9\024\ufff9\027\ufff9\030\ufff9\032\ufff9\033\ufff9" +
    "\043\ufff9\044\ufff9\046\ufff9\001\002\000\006\026\374\046" +
    "\027\001\002\000\004\020\365\001\002\000\004\046\212" +
    "\001\002\000\014\002\ufff6\020\ufff6\032\ufff6\033\ufff6\046" +
    "\ufff6\001\002\000\036\002\ufff8\003\ufff8\020\ufff8\021\ufff8" +
    "\022\ufff8\023\ufff8\024\ufff8\027\ufff8\030\ufff8\032\ufff8\033" +
    "\ufff8\043\ufff8\044\ufff8\046\ufff8\001\002\000\036\002\uffe5" +
    "\003\uffe5\020\uffe5\021\uffe5\022\uffe5\023\uffe5\024\uffe5\027" +
    "\uffe5\030\uffe5\032\uffe5\033\uffe5\043\uffe5\044\uffe5\046\uffe5" +
    "\001\002\000\014\002\ufffe\020\013\032\020\033\026\046" +
    "\021\001\002\000\004\046\027\001\002\000\006\003\031" +
    "\036\030\001\002\000\010\003\uff79\020\033\037\uff79\001" +
    "\002\000\006\020\033\037\uff79\001\002\000\004\037\040" +
    "\001\002\000\004\046\034\001\002\000\010\003\uff7a\037" +
    "\uff7a\042\035\001\002\000\010\003\037\020\033\037\uff79" +
    "\001\002\000\006\003\uff7c\037\uff7c\001\002\000\006\003" +
    "\uff7b\037\uff7b\001\002\000\006\003\041\043\042\001\002" +
    "\000\034\003\ufff6\020\ufff6\021\ufff6\022\ufff6\023\ufff6\024" +
    "\ufff6\027\ufff6\030\ufff6\032\ufff6\033\ufff6\043\ufff6\044\ufff6" +
    "\046\ufff6\001\002\000\034\003\ufff6\020\ufff6\021\ufff6\022" +
    "\ufff6\023\ufff6\024\ufff6\027\ufff6\030\ufff6\032\ufff6\033\ufff6" +
    "\043\ufff6\044\ufff6\046\ufff6\001\002\000\036\002\uffe0\003" +
    "\uffe0\020\uffe0\021\uffe0\022\uffe0\023\uffe0\024\uffe0\027\uffe0" +
    "\030\uffe0\032\uffe0\033\uffe0\043\uffe0\044\uffe0\046\uffe0\001" +
    "\002\000\034\003\067\020\013\021\066\022\053\023\057" +
    "\024\052\027\055\030\060\032\020\033\026\043\045\044" +
    "\uffd9\046\061\001\002\000\026\003\067\021\066\022\053" +
    "\023\057\024\052\027\055\030\060\043\045\044\uffd9\046" +
    "\073\001\002\000\006\003\350\044\351\001\002\000\006" +
    "\003\346\034\347\001\002\000\010\012\341\013\340\014" +
    "\337\001\002\000\026\003\uffd6\021\uffd6\022\uffd6\023\uffd6" +
    "\024\uffd6\027\uffd6\030\uffd6\043\uffd6\044\uffd6\046\uffd6\001" +
    "\002\000\004\036\326\001\002\000\006\003\315\036\314" +
    "\001\002\000\026\003\uffd7\021\uffd7\022\uffd7\023\uffd7\024" +
    "\uffd7\027\uffd7\030\uffd7\043\uffd7\044\uffd7\046\uffd7\001\002" +
    "\000\016\003\311\011\106\034\307\036\105\046\104\047" +
    "\103\001\002\000\026\003\067\021\066\022\053\023\057" +
    "\024\052\027\055\030\060\043\045\044\uffd9\046\073\001" +
    "\002\000\004\036\251\001\002\000\004\036\224\001\002" +
    "\000\020\003\077\012\102\013\101\014\075\036\076\040" +
    "\100\046\212\001\002\000\006\003\207\034\210\001\002" +
    "\000\026\003\uffd8\021\uffd8\022\uffd8\023\uffd8\024\uffd8\027" +
    "\uffd8\030\uffd8\043\uffd8\044\uffd8\046\uffd8\001\002\000\006" +
    "\003\205\034\206\001\002\000\026\003\067\021\066\022" +
    "\053\023\057\024\052\027\055\030\060\043\045\044\uffd9" +
    "\046\073\001\002\000\006\003\173\036\172\001\002\000" +
    "\030\003\067\021\066\022\053\023\057\024\052\027\055" +
    "\030\060\034\074\043\045\044\uffd9\046\073\001\002\000" +
    "\004\003\071\001\002\000\026\003\uffd5\021\uffd5\022\uffd5" +
    "\023\uffd5\024\uffd5\027\uffd5\030\uffd5\043\uffd5\044\uffd5\046" +
    "\uffd5\001\002\000\004\044\171\001\002\000\016\003\077" +
    "\012\102\013\101\014\075\036\076\040\100\001\002\000" +
    "\032\003\uffca\017\uffca\021\uffca\022\uffca\023\uffca\024\uffca" +
    "\027\uffca\030\uffca\031\uffca\043\uffca\044\uffca\046\uffca\001" +
    "\002\000\014\003\167\011\106\036\105\046\104\047\103" +
    "\001\002\000\016\003\162\011\106\036\105\037\uff7d\046" +
    "\104\047\103\001\002\000\016\003\121\011\106\036\105" +
    "\037\uff7d\046\104\047\103\001\002\000\014\003\121\011" +
    "\106\036\105\046\104\047\103\001\002\000\014\003\107" +
    "\011\106\036\105\046\104\047\103\001\002\000\006\003" +
    "\uffb8\034\uffb8\001\002\000\030\003\uffc9\004\uffc9\005\uffc9" +
    "\006\uffc9\007\uffc9\010\uffc9\012\uffc9\034\uffc9\037\uffc9\041" +
    "\uffc9\042\uffc9\001\002\000\034\003\uffc0\004\uffc0\005\uffc0" +
    "\006\uffc0\007\uffc0\010\uffc0\012\uffc0\034\uffc0\036\136\037" +
    "\uffc0\040\100\041\uffc0\042\uffc0\001\002\000\014\003\121" +
    "\011\106\036\105\046\104\047\103\001\002\000\014\003" +
    "\121\011\106\036\105\046\104\047\103\001\002\000\014" +
    "\011\106\034\uffb2\036\105\046\104\047\103\001\002\000" +
    "\030\003\uffc8\004\uffc8\005\uffc8\006\uffc8\007\uffc8\010\uffc8" +
    "\012\uffc8\034\uffc8\037\uffc8\041\uffc8\042\uffc8\001\002\000" +
    "\030\003\uffc1\004\uffc1\005\uffc1\006\uffc1\007\uffc1\010\uffc1" +
    "\012\uffc1\034\uffc1\037\uffc1\041\uffc1\042\uffc1\001\002\000" +
    "\022\003\uffba\004\115\005\116\006\117\007\113\010\114" +
    "\012\120\034\uffba\001\002\000\014\003\121\011\106\036" +
    "\105\046\104\047\103\001\002\000\014\003\121\011\106" +
    "\036\105\046\104\047\103\001\002\000\014\003\121\011" +
    "\106\036\105\046\104\047\103\001\002\000\014\003\121" +
    "\011\106\036\105\046\104\047\103\001\002\000\014\003" +
    "\121\011\106\036\105\046\104\047\103\001\002\000\030" +
    "\003\uffc2\004\uffc2\005\uffc2\006\uffc2\007\uffc2\010\uffc2\012" +
    "\uffc2\034\uffc2\037\uffc2\041\uffc2\042\uffc2\001\002\000\016" +
    "\003\121\011\106\034\123\036\105\046\104\047\103\001" +
    "\002\000\030\003\uffbd\004\uffbd\005\uffbd\006\uffbd\007\113" +
    "\010\114\012\uffbd\034\uffbd\037\uffbd\041\uffbd\042\uffbd\001" +
    "\002\000\030\003\uffbb\004\uffbb\005\uffbb\006\uffbb\007\uffbb" +
    "\010\uffbb\012\uffbb\034\uffbb\037\uffbb\041\uffbb\042\uffbb\001" +
    "\002\000\020\004\115\005\116\006\117\007\113\010\114" +
    "\012\120\037\125\001\002\000\030\003\uffc5\004\uffc5\005" +
    "\uffc5\006\uffc5\007\uffc5\010\uffc5\012\uffc5\034\uffc5\037\uffc5" +
    "\041\uffc5\042\uffc5\001\002\000\030\003\uffc4\004\115\005" +
    "\uffc4\006\117\007\113\010\114\012\120\034\uffc4\037\uffc4" +
    "\041\uffc4\042\uffc4\001\002\000\030\003\uffc3\004\uffc3\005" +
    "\uffc3\006\117\007\113\010\114\012\120\034\uffc3\037\uffc3" +
    "\041\uffc3\042\uffc3\001\002\000\030\003\uffbf\004\uffbf\005" +
    "\uffbf\006\uffbf\007\uffbf\010\uffbf\012\uffbf\034\uffbf\037\uffbf" +
    "\041\uffbf\042\uffbf\001\002\000\030\003\uffbe\004\uffbe\005" +
    "\uffbe\006\uffbe\007\uffbe\010\114\012\uffbe\034\uffbe\037\uffbe" +
    "\041\uffbe\042\uffbe\001\002\000\030\003\uffbc\004\uffbc\005" +
    "\uffbc\006\117\007\113\010\114\012\120\034\uffbc\037\uffbc" +
    "\041\uffbc\042\uffbc\001\002\000\022\003\134\004\115\005" +
    "\116\006\117\007\113\010\114\012\120\037\135\001\002" +
    "\000\030\003\uffc6\004\uffc6\005\uffc6\006\uffc6\007\uffc6\010" +
    "\uffc6\012\uffc6\034\uffc6\037\uffc6\041\uffc6\042\uffc6\001\002" +
    "\000\030\003\uffc7\004\uffc7\005\uffc7\006\uffc7\007\uffc7\010" +
    "\uffc7\012\uffc7\034\uffc7\037\uffc7\041\uffc7\042\uffc7\001\002" +
    "\000\016\003\150\011\106\036\105\037\uff7d\046\104\047" +
    "\103\001\002\000\016\003\121\011\106\036\105\037\uff7d" +
    "\046\104\047\103\001\002\000\024\004\115\005\116\006" +
    "\117\007\113\010\114\012\120\037\uff7f\041\144\042\143" +
    "\001\002\000\004\037\142\001\002\000\030\003\uff83\004" +
    "\uff83\005\uff83\006\uff83\007\uff83\010\uff83\012\uff83\034\uff83" +
    "\037\uff83\041\uff83\042\uff83\001\002\000\016\003\146\011" +
    "\106\036\105\037\uff7d\046\104\047\103\001\002\000\034" +
    "\003\uff77\004\uff77\005\uff77\006\uff77\007\uff77\010\uff77\012" +
    "\uff77\013\uff77\014\uff77\034\uff77\037\uff77\041\uff77\042\uff77" +
    "\001\002\000\024\003\uff7f\004\115\005\116\006\117\007" +
    "\113\010\114\012\120\037\uff7f\042\143\001\002\000\016" +
    "\011\106\034\123\036\105\037\uff7e\046\104\047\103\001" +
    "\002\000\006\003\uff80\037\uff80\001\002\000\020\003\121" +
    "\011\106\034\123\036\105\037\154\046\104\047\103\001" +
    "\002\000\006\003\152\037\153\001\002\000\030\003\uff82" +
    "\004\uff82\005\uff82\006\uff82\007\uff82\010\uff82\012\uff82\034" +
    "\uff82\037\uff82\041\uff82\042\uff82\001\002\000\030\003\uff84" +
    "\004\uff84\005\uff84\006\uff84\007\uff84\010\uff84\012\uff84\034" +
    "\uff84\037\uff84\041\uff84\042\uff84\001\002\000\030\003\uff81" +
    "\004\uff81\005\uff81\006\uff81\007\uff81\010\uff81\012\uff81\034" +
    "\uff81\037\uff81\041\uff81\042\uff81\001\002\000\022\003\156" +
    "\004\115\005\116\006\117\007\113\010\114\012\120\041" +
    "\157\001\002\000\034\003\uff76\004\uff76\005\uff76\006\uff76" +
    "\007\uff76\010\uff76\012\uff76\013\uff76\014\uff76\034\uff76\037" +
    "\uff76\041\uff76\042\uff76\001\002\000\034\003\uff78\004\uff78" +
    "\005\uff78\006\uff78\007\uff78\010\uff78\012\uff78\013\uff78\014" +
    "\uff78\034\uff78\037\uff78\041\uff78\042\uff78\001\002\000\004" +
    "\037\161\001\002\000\006\003\uff87\034\uff87\001\002\000" +
    "\020\003\121\011\106\034\123\036\105\037\166\046\104" +
    "\047\103\001\002\000\006\003\164\037\165\001\002\000" +
    "\006\003\uff86\034\uff86\001\002\000\006\003\uff88\034\uff88" +
    "\001\002\000\006\003\uff85\034\uff85\001\002\000\014\011" +
    "\106\034\uffb1\036\105\046\104\047\103\001\002\000\022" +
    "\003\uffb9\004\115\005\116\006\117\007\113\010\114\012" +
    "\120\034\uffb9\001\002\000\032\003\uff92\017\uff92\021\uff92" +
    "\022\uff92\023\uff92\024\uff92\027\uff92\030\uff92\031\uff92\043" +
    "\uff92\044\uff92\046\uff92\001\002\000\016\003\177\011\106" +
    "\036\105\045\176\046\104\047\103\001\002\000\016\003" +
    "\121\011\106\036\105\037\uff7d\046\104\047\103\001\002" +
    "\000\004\037\175\001\002\000\006\003\uff8e\034\uff8e\001" +
    "\002\000\004\037\203\001\002\000\020\003\121\011\106" +
    "\034\123\036\105\037\202\046\104\047\103\001\002\000" +
    "\004\003\201\001\002\000\006\003\uff8d\034\uff8d\001\002" +
    "\000\006\003\uff8c\034\uff8c\001\002\000\006\003\uff90\034" +
    "\uff90\001\002\000\006\003\uffda\044\uffda\001\002\000\032" +
    "\003\uffcd\017\uffcd\021\uffcd\022\uffcd\023\uffcd\024\uffcd\027" +
    "\uffcd\030\uffcd\031\uffcd\043\uffcd\044\uffcd\046\uffcd\001\002" +
    "\000\032\003\uffd2\017\uffd2\021\uffd2\022\uffd2\023\uffd2\024" +
    "\uffd2\027\uffd2\030\uffd2\031\uffd2\043\uffd2\044\uffd2\046\uffd2" +
    "\001\002\000\032\003\uffcf\017\uffcf\021\uffcf\022\uffcf\023" +
    "\uffcf\024\uffcf\027\uffcf\030\uffcf\031\uffcf\043\uffcf\044\uffcf" +
    "\046\uffcf\001\002\000\032\003\uffd4\017\uffd4\021\uffd4\022" +
    "\uffd4\023\uffd4\024\uffd4\027\uffd4\030\uffd4\031\uffd4\043\uffd4" +
    "\044\uffd4\046\uffd4\001\002\000\010\003\uffea\034\uffea\042" +
    "\221\001\002\000\012\003\uffe7\013\216\034\uffe7\042\uffe7" +
    "\001\002\000\006\003\214\034\215\001\002\000\036\002" +
    "\uffed\003\uffed\020\uffed\021\uffed\022\uffed\023\uffed\024\uffed" +
    "\027\uffed\030\uffed\032\uffed\033\uffed\043\uffed\044\uffed\046" +
    "\uffed\001\002\000\036\002\uffef\003\uffef\020\uffef\021\uffef" +
    "\022\uffef\023\uffef\024\uffef\027\uffef\030\uffef\032\uffef\033" +
    "\uffef\043\uffef\044\uffef\046\uffef\001\002\000\014\003\217" +
    "\011\106\036\105\046\104\047\103\001\002\000\016\011" +
    "\106\034\uffe8\036\105\042\uffe8\046\104\047\103\001\002" +
    "\000\024\003\uffe9\004\115\005\116\006\117\007\113\010" +
    "\114\012\120\034\uffe9\042\uffe9\001\002\000\006\003\222" +
    "\046\212\001\002\000\006\003\uffeb\034\uffeb\001\002\000" +
    "\006\003\uffec\034\uffec\001\002\000\014\003\225\011\106" +
    "\036\105\046\104\047\103\001\002\000\020\003\121\011" +
    "\106\034\123\036\105\037\240\046\104\047\103\001\002" +
    "\000\020\004\115\005\116\006\117\007\113\010\114\012" +
    "\120\037\227\001\002\000\016\003\067\021\066\022\053" +
    "\027\055\043\045\046\073\001\002\000\030\003\uffad\021" +
    "\uffad\022\uffad\023\uffad\024\uffad\027\uffad\030\uffad\031\235" +
    "\043\uffad\044\uffad\046\uffad\001\002\000\030\003\uffb0\021" +
    "\uffb0\022\uffb0\023\uffb0\024\uffb0\027\uffb0\030\uffb0\031\232" +
    "\043\uffb0\044\uffb0\046\uffb0\001\002\000\016\003\067\021" +
    "\066\022\053\027\055\043\045\046\073\001\002\000\026" +
    "\003\uffae\021\uffae\022\uffae\023\uffae\024\uffae\027\uffae\030" +
    "\uffae\043\uffae\044\uffae\046\uffae\001\002\000\026\003\uffaf" +
    "\021\uffaf\022\uffaf\023\uffaf\024\uffaf\027\uffaf\030\uffaf\043" +
    "\uffaf\044\uffaf\046\uffaf\001\002\000\016\003\067\021\066" +
    "\022\053\027\055\043\045\046\073\001\002\000\026\003" +
    "\uffab\021\uffab\022\uffab\023\uffab\024\uffab\027\uffab\030\uffab" +
    "\043\uffab\044\uffab\046\uffab\001\002\000\026\003\uffac\021" +
    "\uffac\022\uffac\023\uffac\024\uffac\027\uffac\030\uffac\043\uffac" +
    "\044\uffac\046\uffac\001\002\000\016\003\067\021\066\022" +
    "\053\027\055\043\045\046\073\001\002\000\030\003\uffa7" +
    "\021\uffa7\022\uffa7\023\uffa7\024\uffa7\027\uffa7\030\uffa7\031" +
    "\246\043\uffa7\044\uffa7\046\uffa7\001\002\000\030\003\uffaa" +
    "\021\uffaa\022\uffaa\023\uffaa\024\uffaa\027\uffaa\030\uffaa\031" +
    "\243\043\uffaa\044\uffaa\046\uffaa\001\002\000\016\003\067" +
    "\021\066\022\053\027\055\043\045\046\073\001\002\000" +
    "\026\003\uffa8\021\uffa8\022\uffa8\023\uffa8\024\uffa8\027\uffa8" +
    "\030\uffa8\043\uffa8\044\uffa8\046\uffa8\001\002\000\026\003" +
    "\uffa9\021\uffa9\022\uffa9\023\uffa9\024\uffa9\027\uffa9\030\uffa9" +
    "\043\uffa9\044\uffa9\046\uffa9\001\002\000\016\003\067\021" +
    "\066\022\053\027\055\043\045\046\073\001\002\000\026" +
    "\003\uffa5\021\uffa5\022\uffa5\023\uffa5\024\uffa5\027\uffa5\030" +
    "\uffa5\043\uffa5\044\uffa5\046\uffa5\001\002\000\026\003\uffa6" +
    "\021\uffa6\022\uffa6\023\uffa6\024\uffa6\027\uffa6\030\uffa6\043" +
    "\uffa6\044\uffa6\046\uffa6\001\002\000\014\003\121\011\106" +
    "\036\105\046\104\047\103\001\002\000\020\004\115\005" +
    "\116\006\117\007\113\010\114\012\120\037\253\001\002" +
    "\000\004\043\254\001\002\000\010\015\257\025\255\044" +
    "\uff9b\001\002\000\004\035\273\001\002\000\004\044\272" +
    "\001\002\000\004\047\260\001\002\000\004\035\261\001" +
    "\002\000\016\003\067\021\066\022\053\027\055\043\045" +
    "\046\073\001\002\000\004\017\267\001\002\000\004\017" +
    "\264\001\002\000\004\034\265\001\002\000\010\015\257" +
    "\025\255\044\uff9b\001\002\000\004\044\uffa3\001\002\000" +
    "\004\034\270\001\002\000\010\015\257\025\255\044\uff9b" +
    "\001\002\000\004\044\uff9f\001\002\000\026\003\uffa4\021" +
    "\uffa4\022\uffa4\023\uffa4\024\uffa4\027\uffa4\030\uffa4\043\uffa4" +
    "\044\uffa4\046\uffa4\001\002\000\016\003\067\021\066\022" +
    "\053\027\055\043\045\046\073\001\002\000\006\003\302" +
    "\017\303\001\002\000\006\003\276\017\277\001\002\000" +
    "\004\044\uffa1\001\002\000\006\003\300\034\301\001\002" +
    "\000\004\044\uffa0\001\002\000\004\044\uffa2\001\002\000" +
    "\004\044\uff9d\001\002\000\006\003\304\034\305\001\002" +
    "\000\004\044\uff9c\001\002\000\004\044\uff9e\001\002\000" +
    "\006\003\uffdb\044\uffdb\001\002\000\032\003\uffd0\017\uffd0" +
    "\021\uffd0\022\uffd0\023\uffd0\024\uffd0\027\uffd0\030\uffd0\031" +
    "\uffd0\043\uffd0\044\uffd0\046\uffd0\001\002\000\022\003\312" +
    "\004\115\005\116\006\117\007\113\010\114\012\120\034" +
    "\313\001\002\000\040\011\106\017\uffcb\021\uffcb\022\uffcb" +
    "\023\uffcb\024\uffcb\027\uffcb\030\uffcb\031\uffcb\034\123\036" +
    "\105\043\uffcb\044\uffcb\046\104\047\103\001\002\000\032" +
    "\003\uffcc\017\uffcc\021\uffcc\022\uffcc\023\uffcc\024\uffcc\027" +
    "\uffcc\030\uffcc\031\uffcc\043\uffcc\044\uffcc\046\uffcc\001\002" +
    "\000\032\003\uffd1\017\uffd1\021\uffd1\022\uffd1\023\uffd1\024" +
    "\uffd1\027\uffd1\030\uffd1\031\uffd1\043\uffd1\044\uffd1\046\uffd1" +
    "\001\002\000\014\003\321\011\106\036\105\046\104\047" +
    "\103\001\002\000\016\003\121\011\106\036\105\037\uff7d" +
    "\046\104\047\103\001\002\000\004\037\317\001\002\000" +
    "\006\003\uff8b\034\uff8b\001\002\000\024\003\uff7f\004\115" +
    "\005\116\006\117\007\113\010\114\012\120\037\325\042" +
    "\143\001\002\000\020\003\121\011\106\034\123\036\105" +
    "\037\324\046\104\047\103\001\002\000\004\003\323\001" +
    "\002\000\006\003\uff8a\034\uff8a\001\002\000\006\003\uff89" +
    "\034\uff89\001\002\000\006\003\uff8f\034\uff8f\001\002\000" +
    "\014\003\327\011\106\036\105\046\104\047\103\001\002" +
    "\000\020\003\121\011\106\034\123\036\105\037\334\046" +
    "\104\047\103\001\002\000\020\004\115\005\116\006\117" +
    "\007\113\010\114\012\120\037\331\001\002\000\016\003" +
    "\067\021\066\022\053\027\055\043\045\046\073\001\002" +
    "\000\026\003\uff99\021\uff99\022\uff99\023\uff99\024\uff99\027" +
    "\uff99\030\uff99\043\uff99\044\uff99\046\uff99\001\002\000\026" +
    "\003\uff9a\021\uff9a\022\uff9a\023\uff9a\024\uff9a\027\uff9a\030" +
    "\uff9a\043\uff9a\044\uff9a\046\uff9a\001\002\000\016\003\067" +
    "\021\066\022\053\027\055\043\045\046\073\001\002\000" +
    "\026\003\uff97\021\uff97\022\uff97\023\uff97\024\uff97\027\uff97" +
    "\030\uff97\043\uff97\044\uff97\046\uff97\001\002\000\026\003" +
    "\uff98\021\uff98\022\uff98\023\uff98\024\uff98\027\uff98\030\uff98" +
    "\043\uff98\044\uff98\046\uff98\001\002\000\014\003\344\011" +
    "\106\036\105\046\104\047\103\001\002\000\014\003\342" +
    "\011\106\036\105\046\104\047\103\001\002\000\006\003" +
    "\uffb5\034\uffb5\001\002\000\014\011\106\034\uffb4\036\105" +
    "\046\104\047\103\001\002\000\022\003\uffb7\004\115\005" +
    "\116\006\117\007\113\010\114\012\120\034\uffb7\001\002" +
    "\000\014\011\106\034\uffb3\036\105\046\104\047\103\001" +
    "\002\000\022\003\uffb6\004\115\005\116\006\117\007\113" +
    "\010\114\012\120\034\uffb6\001\002\000\032\003\uffce\017" +
    "\uffce\021\uffce\022\uffce\023\uffce\024\uffce\027\uffce\030\uffce" +
    "\031\uffce\043\uffce\044\uffce\046\uffce\001\002\000\032\003" +
    "\uffd3\017\uffd3\021\uffd3\022\uffd3\023\uffd3\024\uffd3\027\uffd3" +
    "\030\uffd3\031\uffd3\043\uffd3\044\uffd3\046\uffd3\001\002\000" +
    "\036\002\uff94\003\uff94\020\uff94\021\uff94\022\uff94\023\uff94" +
    "\024\uff94\027\uff94\030\uff94\032\uff94\033\uff94\043\uff94\044" +
    "\uff94\046\uff94\001\002\000\036\002\uff96\003\uff96\020\uff96" +
    "\021\uff96\022\uff96\023\uff96\024\uff96\027\uff96\030\uff96\032" +
    "\uff96\033\uff96\043\uff96\044\uff96\046\uff96\001\002\000\006" +
    "\003\353\044\354\001\002\000\032\003\uff91\017\uff91\021" +
    "\uff91\022\uff91\023\uff91\024\uff91\027\uff91\030\uff91\031\uff91" +
    "\043\uff91\044\uff91\046\uff91\001\002\000\032\003\uff93\017" +
    "\uff93\021\uff93\022\uff93\023\uff93\024\uff93\027\uff93\030\uff93" +
    "\031\uff93\043\uff93\044\uff93\046\uff93\001\002\000\034\003" +
    "\067\020\013\021\066\022\053\023\057\024\052\027\055" +
    "\030\060\032\020\033\026\043\045\044\uffd9\046\061\001" +
    "\002\000\004\044\357\001\002\000\036\002\uff95\003\uff95" +
    "\020\uff95\021\uff95\022\uff95\023\uff95\024\uff95\027\uff95\030" +
    "\uff95\032\uff95\033\uff95\043\uff95\044\uff95\046\uff95\001\002" +
    "\000\006\003\361\037\362\001\002\000\006\003\041\043" +
    "\042\001\002\000\006\003\041\043\042\001\002\000\036" +
    "\002\uffe1\003\uffe1\020\uffe1\021\uffe1\022\uffe1\023\uffe1\024" +
    "\uffe1\027\uffe1\030\uffe1\032\uffe1\033\uffe1\043\uffe1\044\uffe1" +
    "\046\uffe1\001\002\000\036\002\uffdf\003\uffdf\020\uffdf\021" +
    "\uffdf\022\uffdf\023\uffdf\024\uffdf\027\uffdf\030\uffdf\032\uffdf" +
    "\033\uffdf\043\uffdf\044\uffdf\046\uffdf\001\002\000\004\046" +
    "\366\001\002\000\004\040\367\001\002\000\004\047\370" +
    "\001\002\000\004\041\371\001\002\000\006\003\373\034" +
    "\372\001\002\000\036\002\ufff2\003\ufff2\020\ufff2\021\ufff2" +
    "\022\ufff2\023\ufff2\024\ufff2\027\ufff2\030\ufff2\032\ufff2\033" +
    "\ufff2\043\ufff2\044\ufff2\046\ufff2\001\002\000\036\002\ufff1" +
    "\003\ufff1\020\ufff1\021\ufff1\022\ufff1\023\ufff1\024\ufff1\027" +
    "\ufff1\030\ufff1\032\ufff1\033\ufff1\043\ufff1\044\ufff1\046\ufff1" +
    "\001\002\000\006\003\376\036\375\001\002\000\010\003" +
    "\uff79\020\033\037\u0103\001\002\000\006\020\033\037\uff79" +
    "\001\002\000\004\037\u0100\001\002\000\006\003\041\043" +
    "\042\001\002\000\014\002\uffdd\020\uffdd\032\uffdd\033\uffdd" +
    "\046\uffdd\001\002\000\004\003\u0105\001\002\000\006\003" +
    "\041\043\042\001\002\000\014\002\uffde\020\uffde\032\uffde" +
    "\033\uffde\046\uffde\001\002\000\006\003\041\043\042\001" +
    "\002\000\014\002\uffdc\020\uffdc\032\uffdc\033\uffdc\046\uffdc" +
    "\001\002\000\014\003\uffe7\013\216\034\uffe7\036\u010b\042" +
    "\uffe7\001\002\000\006\003\u0109\034\u010a\001\002\000\036" +
    "\002\uffee\003\uffee\020\uffee\021\uffee\022\uffee\023\uffee\024" +
    "\uffee\027\uffee\030\uffee\032\uffee\033\uffee\043\uffee\044\uffee" +
    "\046\uffee\001\002\000\036\002\ufff0\003\ufff0\020\ufff0\021" +
    "\ufff0\022\ufff0\023\ufff0\024\ufff0\027\ufff0\030\ufff0\032\ufff0" +
    "\033\ufff0\043\ufff0\044\ufff0\046\ufff0\001\002\000\010\003" +
    "\uff79\020\033\037\uff79\001\002\000\006\020\033\037\uff79" +
    "\001\002\000\004\037\u010e\001\002\000\006\003\041\043" +
    "\042\001\002\000\036\002\uffe3\003\uffe3\020\uffe3\021\uffe3" +
    "\022\uffe3\023\uffe3\024\uffe3\027\uffe3\030\uffe3\032\uffe3\033" +
    "\uffe3\043\uffe3\044\uffe3\046\uffe3\001\002\000\006\003\u0111" +
    "\037\u0112\001\002\000\006\003\041\043\042\001\002\000" +
    "\006\003\041\043\042\001\002\000\036\002\uffe4\003\uffe4" +
    "\020\uffe4\021\uffe4\022\uffe4\023\uffe4\024\uffe4\027\uffe4\030" +
    "\uffe4\032\uffe4\033\uffe4\043\uffe4\044\uffe4\046\uffe4\001\002" +
    "\000\036\002\uffe2\003\uffe2\020\uffe2\021\uffe2\022\uffe2\023" +
    "\uffe2\024\uffe2\027\uffe2\030\uffe2\032\uffe2\033\uffe2\043\uffe2" +
    "\044\uffe2\046\uffe2\001\002\000\004\047\u0116\001\002\000" +
    "\006\003\u0118\034\u0117\001\002\000\014\016\ufffb\020\ufffb" +
    "\032\ufffb\033\ufffb\046\ufffb\001\002\000\014\016\ufffa\020" +
    "\ufffa\032\ufffa\033\ufffa\046\ufffa\001\002\000\004\002\001" +
    "\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\u0117\000\006\002\003\042\004\001\001\000\002\001" +
    "\001\000\006\003\005\004\006\001\001\000\002\001\001" +
    "\000\006\005\011\006\010\001\001\000\002\001\001\000" +
    "\016\010\022\011\015\015\013\016\014\017\023\020\021" +
    "\001\001\000\002\001\001\000\006\012\u0107\013\210\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\012\212\013" +
    "\210\001\001\000\004\006\024\001\001\000\002\001\001" +
    "\000\002\001\001\000\014\010\022\011\015\015\013\016" +
    "\014\017\023\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\021\357\001\001\000\004\021\031\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\021\035\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\035\042\001\001\000\004\006\354\001\001\000\004" +
    "\006\043\001\001\000\002\001\001\000\042\010\022\011" +
    "\015\015\013\016\014\017\023\022\045\023\055\025\061" +
    "\026\062\030\050\031\053\032\046\033\063\034\067\040" +
    "\047\041\064\001\001\000\030\022\351\023\055\025\061" +
    "\026\062\030\050\031\053\032\046\033\063\034\067\040" +
    "\047\041\064\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\010\014\107\024\307" +
    "\040\110\001\001\000\030\022\305\023\055\025\061\026" +
    "\062\030\050\031\053\032\046\033\063\034\067\040\047" +
    "\041\064\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\012\212\013\210\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\030\022\203\023\055\025" +
    "\061\026\062\030\050\031\053\032\046\033\063\034\067" +
    "\040\047\041\064\001\001\000\002\001\001\000\030\022" +
    "\071\023\055\025\061\026\062\030\050\031\053\032\046" +
    "\033\063\034\067\040\047\041\064\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\010\014\107\024\167\040\110\001" +
    "\001\000\012\014\107\024\144\037\162\040\110\001\001" +
    "\000\012\014\107\024\137\037\157\040\110\001\001\000" +
    "\010\014\107\024\154\040\110\001\001\000\010\014\107" +
    "\024\111\040\110\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\010\014\107\024\132\040\110" +
    "\001\001\000\010\014\107\024\131\040\110\001\001\000" +
    "\010\014\107\024\123\040\110\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\010\014\107\024" +
    "\130\040\110\001\001\000\010\014\107\024\127\040\110" +
    "\001\001\000\010\014\107\024\126\040\110\001\001\000" +
    "\010\014\107\024\125\040\110\001\001\000\010\014\107" +
    "\024\121\040\110\001\001\000\002\001\001\000\010\014" +
    "\107\024\123\040\110\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\012\014\107\024\144\037\150\040\110" +
    "\001\001\000\012\014\107\024\137\037\140\040\110\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\012\014\107\024\144\037\146\040\110\001\001\000" +
    "\002\001\001\000\002\001\001\000\010\014\107\024\123" +
    "\040\110\001\001\000\002\001\001\000\010\014\107\024" +
    "\123\040\110\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\010\014\107\024\123\040\110\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\010\014\107\024\123\040\110\001\001\000" +
    "\002\001\001\000\002\001\001\000\012\014\107\024\144" +
    "\037\177\040\110\001\001\000\012\014\107\024\144\037" +
    "\173\040\110\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\010\014\107\024\123\040\110\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\010\014\107\024\217\040\110" +
    "\001\001\000\010\014\107\024\123\040\110\001\001\000" +
    "\002\001\001\000\006\012\222\013\210\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\014\107\024\225\040" +
    "\110\001\001\000\010\014\107\024\123\040\110\001\001" +
    "\000\002\001\001\000\016\025\061\032\046\033\063\034" +
    "\230\040\047\041\227\001\001\000\002\001\001\000\002" +
    "\001\001\000\016\025\061\032\046\033\063\034\233\040" +
    "\047\041\232\001\001\000\002\001\001\000\002\001\001" +
    "\000\016\025\061\032\046\033\063\034\236\040\047\041" +
    "\235\001\001\000\002\001\001\000\002\001\001\000\016" +
    "\025\061\032\046\033\063\034\241\040\047\041\240\001" +
    "\001\000\002\001\001\000\002\001\001\000\016\025\061" +
    "\032\046\033\063\034\244\040\047\041\243\001\001\000" +
    "\002\001\001\000\002\001\001\000\016\025\061\032\046" +
    "\033\063\034\247\040\047\041\246\001\001\000\002\001" +
    "\001\000\002\001\001\000\010\014\107\024\251\040\110" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\036" +
    "\255\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\016\025\061\032\046\033" +
    "\063\034\262\040\047\041\261\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\036\265\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\036\270" +
    "\001\001\000\002\001\001\000\002\001\001\000\016\025" +
    "\061\032\046\033\063\034\274\040\047\041\273\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\010\014\107\024\123\040\110\001\001\000\002\001" +
    "\001\000\002\001\001\000\012\014\107\024\317\037\321" +
    "\040\110\001\001\000\012\014\107\024\144\037\315\040" +
    "\110\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\010\014\107\024\123\040\110\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\010\014\107\024\327\040\110\001\001\000" +
    "\010\014\107\024\123\040\110\001\001\000\002\001\001" +
    "\000\016\025\061\032\046\033\063\034\332\040\047\041" +
    "\331\001\001\000\002\001\001\000\002\001\001\000\016" +
    "\025\061\032\046\033\063\034\335\040\047\041\334\001" +
    "\001\000\002\001\001\000\002\001\001\000\010\014\107" +
    "\024\344\040\110\001\001\000\010\014\107\024\342\040" +
    "\110\001\001\000\002\001\001\000\010\014\107\024\123" +
    "\040\110\001\001\000\002\001\001\000\010\014\107\024" +
    "\123\040\110\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\042" +
    "\010\022\011\015\015\013\016\014\017\023\022\355\023" +
    "\055\025\061\026\062\030\050\031\053\032\046\033\063" +
    "\034\067\040\047\041\064\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\035\363\001\001" +
    "\000\004\035\362\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\021\u0101\001\001" +
    "\000\004\021\376\001\001\000\002\001\001\000\004\035" +
    "\u0100\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\035\u0103\001\001\000\002\001\001\000\004\035\u0105\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\021\u010f\001" +
    "\001\000\004\021\u010c\001\001\000\002\001\001\000\004" +
    "\035\u010e\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\035\u0113\001\001\000\004\035\u0112\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {


	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

	public void emitirMensajeError(String msg){
		syntaxErrorManager.syntaxError("ERROR SINTACTICO: "  + msg);
	}

	public void emitirMensajeInfo(String msg){
		syntaxErrorManager.syntaxInfo("INFO SINTAXIS: "  + msg);
	}


  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // accesoVector ::= ID CORCHOP expresion error 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		emitirMensajeError("Corchetes mal balanceados para el acceso al vector " + i .getLexema() + " en la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("accesoVector",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // accesoVector ::= ID error expresion CORCHCL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		emitirMensajeError("Corchetes mal balanceados para el acceso al vector " + i .getLexema() + " en la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("accesoVector",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // accesoVector ::= ID CORCHOP expresion CORCHCL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("accesoVector",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // argsDec ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("argsDec",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // argsDec ::= INT ID 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("argsDec",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // argsDec ::= INT ID COMMA error 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token c = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		emitirMensajeError("Se esperaba una definicion de un argumento tras la coma en la linea" + c.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("argsDec",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // argsDec ::= INT ID COMMA argsDec 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("argsDec",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // argsIn ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("argsIn",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // argsIn ::= expresion COMMA error 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token c = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		emitirMensajeError("Se esperaba una entrada de un argumento tras la coma en la linea" + c.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("argsIn",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // argsIn ::= expresion 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("argsIn",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // argsIn ::= expresion COMMA argsIn 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("argsIn",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // llamadaFuncNum ::= ID PARENOP error PARENCL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		emitirMensajeError("Argumentos de entrada invalidos para la llamada a la funcion " + i.getLexema() + " en la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadaFuncNum",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // llamadaFuncNum ::= ID PARENOP argsIn error 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		emitirMensajeError("Parentesis mal balanceados para la llamada a la funcion " + i.getLexema() + " en la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadaFuncNum",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // llamadaFuncNum ::= ID error argsIn PARENCL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		emitirMensajeError("Parentesis mal balanceados para la llamada a la funcion " + i.getLexema() + " en la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadaFuncNum",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // llamadaFuncNum ::= ID PARENOP argsIn PARENCL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadaFuncNum",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // llamadaVoid ::= ID PARENOP error PARENCL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		emitirMensajeError("Argumentos de entrada invalidos para la llamada a la funcion " + i.getLexema() + " en la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadaVoid",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // llamadaVoid ::= ID PARENOP argsIn error 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		emitirMensajeError("Parentesis mal balanceados para la llamada a la funcion " + i.getLexema() + " en la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadaVoid",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // llamadaVoid ::= ID error argsIn PARENCL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		emitirMensajeError("Parentesis mal balanceados para la llamada a la funcion " + i.getLexema() + " en la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadaVoid",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // llamadaVoid ::= ID PARENOP argsIn PARENCL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadaVoid",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // llamadaPrint ::= PRINTINT PARENOP error PARENCL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		emitirMensajeError("Argumentos de entrada invalidos para la llamada a la funcion " + i.getLexema() + " en la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadaPrint",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // llamadaPrint ::= PRINTINT PARENOP argsIn error 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		emitirMensajeError("Parentesis mal balanceados para la llamada a la funcion " + i.getLexema() + " en la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadaPrint",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // llamadaPrint ::= PRINTINT error argsIn PARENCL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		emitirMensajeError("Parentesis mal balanceados para la llamada a la funcion " + i.getLexema() + " en la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadaPrint",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // llamadaPrint ::= PRINT PARENOP error PARENCL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		emitirMensajeError("Argumentos de entrada invalidos para la llamada a la funcion " + i.getLexema() + " en la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadaPrint",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // llamadaPrint ::= PRINT PARENOP argsIn error 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		emitirMensajeError("Parentesis mal balanceados para la llamada a la funcion " + i.getLexema() + " en la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadaPrint",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // llamadaPrint ::= PRINT error argsIn PARENCL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		emitirMensajeError("Parentesis mal balanceados para la llamada a la funcion " + i.getLexema() + " en la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadaPrint",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // llamadaPrint ::= PRINTINT PARENOP expresion PARENCL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadaPrint",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // llamadaPrint ::= PRINT PARENOP STRING PARENCL 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token s = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadaPrint",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // bloqueCodigo ::= LLAVEOP instrucciones error 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token l = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		emitirMensajeError("Llaves desbalanceadas, llave de apertura en la linea " + l.getLine() + " no se cierran nunca");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloqueCodigo",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // bloqueCodigo ::= error instrucciones LLAVECL 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token l = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		emitirMensajeError("Llaves desbalanceadas, llave de cerrado en la linea " + l.getLine() + " no se abren nunca");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloqueCodigo",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // bloqueCodigo ::= LLAVEOP instrucciones LLAVECL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloqueCodigo",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // bloqueCodigoFuncion ::= LLAVEOP decglobal instrucciones error 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token l = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		emitirMensajeError("Llaves desbalanceadas, llave de apertura en la linea " + l.getLine() + " no se cierran nunca");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloqueCodigoFuncion",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // bloqueCodigoFuncion ::= error decglobal instrucciones LLAVECL 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token l = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		emitirMensajeError("Llaves desbalanceadas, llave de cerrado en la linea " + l.getLine() + " no se abren nunca");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloqueCodigoFuncion",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // bloqueCodigoFuncion ::= LLAVEOP decglobal instrucciones LLAVECL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloqueCodigoFuncion",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // bucle ::= WHILE PARENOP error PARENCL instruccionSimple 
            {
              Object RESULT =null;
		int wleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int wright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token w = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		emitirMensajeError("Expersion invalida en bucle de la linea " + w.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("bucle",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // bucle ::= WHILE PARENOP error PARENCL bloqueCodigo 
            {
              Object RESULT =null;
		int wleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int wright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token w = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		emitirMensajeError("Expersion invalida en bucle de la linea " + w.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("bucle",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // bucle ::= WHILE PARENOP expresion PARENCL instruccionSimple 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("bucle",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // bucle ::= WHILE PARENOP expresion PARENCL bloqueCodigo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("bucle",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // casos ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("casos",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // casos ::= DEFAULT TWOPOINTS instruccionSimple BREAK error 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token d = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token b = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 emitirMensajeError("Falta un ; en " + b.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("casos",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // casos ::= DEFAULT TWOPOINTS instruccionSimple error 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token d = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		 emitirMensajeError("No se ha encontrado una directiva parar para el caso predeterminado en la linea "+ d.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("casos",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // casos ::= DEFAULT TWOPOINTS instruccionSimple BREAK SEMICOL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("casos",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // casos ::= CASE NUM TWOPOINTS instruccionSimple BREAK SEMICOL casos 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("casos",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // casos ::= DEFAULT TWOPOINTS bloqueCodigo BREAK error 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token d = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token b = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 emitirMensajeError("Falta un ; en " + b.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("casos",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // casos ::= DEFAULT TWOPOINTS bloqueCodigo error 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token d = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		 emitirMensajeError("No se ha encontrado una directiva parar para el caso predeterminado en la linea "+ d.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("casos",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // casos ::= DEFAULT TWOPOINTS bloqueCodigo BREAK SEMICOL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("casos",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // casos ::= CASE NUM TWOPOINTS bloqueCodigo BREAK SEMICOL casos 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("casos",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // alternativas ::= SWITCH PARENOP expresion PARENCL LLAVEOP casos LLAVECL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("alternativas",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // condicional ::= IF PARENOP error PARENCL instruccionSimple ELSE instruccionSimple 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		emitirMensajeError("Expersion invalida en condicional de la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicional",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // condicional ::= IF PARENOP error PARENCL instruccionSimple ELSE bloqueCodigo 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		emitirMensajeError("Expersion invalida en condicional de la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicional",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // condicional ::= IF PARENOP error PARENCL instruccionSimple 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		emitirMensajeError("Expersion invalida en condicional de la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicional",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // condicional ::= IF PARENOP error PARENCL bloqueCodigo ELSE instruccionSimple 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		emitirMensajeError("Expersion invalida en condicional de la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicional",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // condicional ::= IF PARENOP error PARENCL bloqueCodigo ELSE bloqueCodigo 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		emitirMensajeError("Expersion invalida en condicional de la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicional",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // condicional ::= IF PARENOP error PARENCL bloqueCodigo 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		emitirMensajeError("Expersion invalida en condicional de la linea " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicional",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // condicional ::= IF PARENOP expresion PARENCL instruccionSimple ELSE instruccionSimple 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicional",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // condicional ::= IF PARENOP expresion PARENCL instruccionSimple ELSE bloqueCodigo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicional",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // condicional ::= IF PARENOP expresion PARENCL instruccionSimple 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicional",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // condicional ::= IF PARENOP expresion PARENCL bloqueCodigo ELSE instruccionSimple 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicional",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // condicional ::= IF PARENOP expresion PARENCL bloqueCodigo ELSE bloqueCodigo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicional",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // condicional ::= IF PARENOP expresion PARENCL bloqueCodigo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicional",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // asignacion ::= ID ASIGSUM error 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token a = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		emitirMensajeError("Asignacion invalida en la linea " + a.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignacion",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // asignacion ::= ID ASIG error 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token a = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		emitirMensajeError("Asignacion invalida en la linea " + a.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignacion",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // asignacion ::= accesoVector ASIGSUM error 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token a = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		emitirMensajeError("Asignacion invalida en la linea " + a.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignacion",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // asignacion ::= accesoVector ASIG error 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token a = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		emitirMensajeError("Asignacion invalida en la linea " + a.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignacion",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // asignacion ::= accesoVector AUTOINC 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignacion",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // asignacion ::= accesoVector ASIGSUM expresion 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignacion",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // asignacion ::= accesoVector ASIG expresion 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignacion",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // asignacion ::= ID AUTOINC 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignacion",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // asignacion ::= ID ASIGSUM expresion 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignacion",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // asignacion ::= ID ASIG expresion 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignacion",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // expresion ::= error SEMICOL 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token s = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 emitirMensajeError("Expresion invalida antes del ; en " + s.getLine()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // expresion ::= NOT expresion 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // expresion ::= expresion LESS expresion 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // expresion ::= expresion EQ expresion 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // expresion ::= expresion AND expresion 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // expresion ::= ID 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",18, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // expresion ::= accesoVector 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",18, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // expresion ::= expresion AUTOINC 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // expresion ::= expresion PLUS expresion 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // expresion ::= expresion PROD expresion 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // expresion ::= error expresion PARENCL 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 emitirMensajeError("Parentesis mal balanceados, parentesis de cerradura en la linea " + p.getLine() + " no cierra nada");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // expresion ::= PARENOP expresion error 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 emitirMensajeError("Parentesis mal balanceados, parentesis de apertura en la linea " + p.getLine() + " no esta cerrado");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // expresion ::= PARENOP expresion PARENCL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // expresion ::= llamadaFuncNum 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",18, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // expresion ::= NUM 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token n = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",18, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // instruccionSimple ::= error SEMICOL 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token s = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 emitirMensajeError("Insturccion invalida antes del ; en " + s.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccionSimple",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // instruccionSimple ::= RETURN error 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token r = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 emitirMensajeError("Falta un ; en " + r.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccionSimple",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // instruccionSimple ::= RETURN expresion error 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token r = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 emitirMensajeError("Falta un ; en " + r.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccionSimple",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // instruccionSimple ::= llamadaPrint error 
            {
              Object RESULT =null;
		 emitirMensajeError("Falta un ; en una llamada a una funcion de escribir");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccionSimple",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // instruccionSimple ::= llamadaVoid error 
            {
              Object RESULT =null;
		 emitirMensajeError("Falta un ; en una llamada a una funcion vacia");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccionSimple",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // instruccionSimple ::= asignacion error 
            {
              Object RESULT =null;
		emitirMensajeError("Falta un ; en una asignacion");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccionSimple",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // instruccionSimple ::= RETURN SEMICOL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccionSimple",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // instruccionSimple ::= RETURN expresion SEMICOL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccionSimple",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // instruccionSimple ::= llamadaPrint SEMICOL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccionSimple",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // instruccionSimple ::= llamadaVoid SEMICOL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccionSimple",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // instruccionSimple ::= asignacion SEMICOL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccionSimple",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // instruccion ::= bloqueCodigo error 
            {
              Object RESULT =null;
		 emitirMensajeError("Un bloque de codigo no puede introducirse de manera independiente");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccion",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // instruccion ::= alternativas 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccion",17, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // instruccion ::= bucle 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccion",17, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // instruccion ::= condicional 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccion",17, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // instrucciones ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("instrucciones",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // instrucciones ::= instruccionSimple instrucciones 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("instrucciones",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // instrucciones ::= instruccion instrucciones 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("instrucciones",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // principal ::= VOID MAIN PARENOP argsDec error bloqueCodigoFuncion 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		emitirMensajeError("Se esperaba un parentesis de cerradura para la función principal en " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("principal",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // principal ::= VOID MAIN error argsDec PARENCL bloqueCodigoFuncion 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		emitirMensajeError("Se esperaba un parentesis de apertura para la función principal en " + i.getLine() );
              CUP$parser$result = parser.getSymbolFactory().newSymbol("principal",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // principal ::= VOID MAIN PARENOP PARENCL bloqueCodigoFuncion 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("principal",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // funcionVacia ::= VOID ID PARENOP argsDec error bloqueCodigoFuncion 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		emitirMensajeError("Se esperaba un parentesis de cerradura para la función " + i.getLexema() + " en " + i.getLine() );
              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcionVacia",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // funcionVacia ::= VOID ID error argsDec PARENCL bloqueCodigoFuncion 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		emitirMensajeError("Se esperaba un parentesis de apertura para la función " + i.getLexema() + " en " + i.getLine() );
              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcionVacia",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // funcionVacia ::= VOID ID PARENOP argsDec PARENCL bloqueCodigoFuncion 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcionVacia",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // funcionEntera ::= INT ID PARENOP argsDec error bloqueCodigoFuncion 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		emitirMensajeError("Se esperaba un parentesis de cerradura para la función " + i.getLexema() + " en " + i.getLine() );
              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcionEntera",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // funcionEntera ::= INT ID error argsDec PARENCL bloqueCodigoFuncion 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		emitirMensajeError("Se esperaba un parentesis de apertura para la función " + i.getLexema() + " en " + i.getLine() );
              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcionEntera",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // funcionEntera ::= INT ID PARENOP argsDec PARENCL bloqueCodigoFuncion 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcionEntera",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // funcion ::= funcionVacia 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcion",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // funcion ::= funcionEntera 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcion",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // decvariable ::= ID 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("decvariable",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // decvariable ::= ID ASIG error 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		emitirMensajeError("Expresion invalida en la asignacion de " + i.getLexema() + " en " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decvariable",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // decvariable ::= ID ASIG expresion 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("decvariable",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // decvariables ::= decvariable 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("decvariables",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // decvariables ::= decvariable COMMA error 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token c = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		emitirMensajeError("Se esperaba una declaracion de variable despues de , en "  + c.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decvariables",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // decvariables ::= decvariable COMMA decvariables 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("decvariables",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // variable ::= ID decvariables error 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		emitirMensajeError("Se esperaba un  ;  en la definicion de variables de tipo " +i.getLexema() + " en " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // variable ::= INT decvariables error 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		emitirMensajeError("Se esperaba un  ;  en la definicion de variables de tipo entero en " + i.getLine());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // variable ::= ID decvariables SEMICOL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // variable ::= INT decvariables SEMICOL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // tipo ::= TYPE INT ID CORCHOP NUM CORCHCL error 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token n = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 emitirMensajeError("Falta un ; en la definifcion del tipo " + i.getLexema() + " en la linea " + i.getLine() ); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // tipo ::= TYPE INT ID CORCHOP NUM CORCHCL SEMICOL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token n = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // declocal ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declocal",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // declocal ::= declocal tipo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declocal",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // declocal ::= declocal variable 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declocal",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // decglobal ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("decglobal",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // decglobal ::= decglobal funcion 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("decglobal",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // decglobal ::= decglobal tipo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("decglobal",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // decglobal ::= decglobal variable 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("decglobal",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // constante ::= CONST ID NUM error 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token n = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 emitirMensajeError("Falta un ; en " + n.getLine() + "despues de " + n.getLexema());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("constante",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // constante ::= CONST ID NUM SEMICOL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token i = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token n = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constante",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // constantes ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constantes",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // constantes ::= constantes constante 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constantes",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // axiom ::= constantes decglobal principal decglobal 
            {
              Axiom RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiom",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program ::= NT$0 axiom 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int axleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int axright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Axiom ax = (Axiom)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		   		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              Object RESULT =null;
 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

